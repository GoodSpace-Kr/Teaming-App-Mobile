import React, { useState, useRef, useEffect } from 'react';
import {
  View,
  Text,
  StyleSheet,
  ScrollView,
  TouchableOpacity,
  TextInput,
  Image,
  Dimensions,
  KeyboardAvoidingView,
  Platform,
  Modal,
  Alert,
  ActivityIndicator,
} from 'react-native';
import { StatusBar } from 'expo-status-bar';
import { router, useLocalSearchParams } from 'expo-router';
import { Ionicons } from '@expo/vector-icons';
import * as ImagePicker from 'expo-image-picker';
import * as DocumentPicker from 'expo-document-picker';
import ChatBubble from '@/src/components/ChatBubble';
import { getAccessToken } from '@/src/services/tokenManager';
import {
  connectSock,
  subscribeRoomSock,
  sendTextSock,
  sendImageSock,
  sendFileSock,
  disconnectSock,
  updateSockToken,
  type ChatMessage,
} from '@/src/services/stompClient';
import { FileService } from '@/src/services/fileService';
import { UploadProgress } from '@/src/types/file';
import {
  getMessageHistory,
  getUserInfo,
  type ChatMessage as ApiChatMessage,
} from '@/src/services/api';

const { width, height } = Dimensions.get('window');

interface Message {
  id: number;
  text: string;
  user: string;
  userImage?: any;
  timestamp: string;
  isMe: boolean;
  readCount?: number; // ÏÑ†ÌÉùÏ†Å ÏÜçÏÑ±ÏúºÎ°ú Î≥ÄÍ≤Ω (ÎÇòÏ§ëÏóê ÏÇ¨Ïö© ÏòàÏ†ï)
  attachments?: any[]; // ÌååÏùº Ï≤®Î∂Ä Ï†ïÎ≥¥
}

interface ChatRoomData {
  id: number;
  title: string;
  subtitle: string;
  members: any;
  memberCount: string;
}

export default function ChatRoomScreen() {
  const { id, role, success, members, title } = useLocalSearchParams<{
    id: string;
    role?: string;
    success?: string;
    members?: string;
    title?: string;
  }>();
  const [inputText, setInputText] = useState('');
  const [showFileMenu, setShowFileMenu] = useState(false);
  const [jwt, setJwt] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [isUploading, setIsUploading] = useState(false);
  const [uploadProgress, setUploadProgress] = useState<UploadProgress | null>(
    null
  );
  const [messages, setMessages] = useState<ChatMessage[]>([]);
  const [isConnected, setIsConnected] = useState(false);
  const [connectionStatus, setConnectionStatus] = useState<
    'connecting' | 'connected' | 'disconnected' | 'error'
  >('disconnected');
  const [currentUserId, setCurrentUserId] = useState<number | null>(null);
  const [currentUserName, setCurrentUserName] = useState<string>('');
  const [isTeamCompleted, setIsTeamCompleted] = useState(false);
  const [actualMembers, setActualMembers] = useState<any[]>([]);
  const scrollViewRef = useRef<ScrollView>(null);

  // JWT ÌÜ†ÌÅ∞ÏóêÏÑú ÏÇ¨Ïö©Ïûê ID Ï∂îÏ∂úÌïòÎäî Ìï®Ïàò
  const getUserIdFromToken = (token: string): number | null => {
    try {
      const payload = JSON.parse(atob(token.split('.')[1]));
      return payload.sub ? parseInt(payload.sub) : null;
    } catch (error) {
      console.error('ÌÜ†ÌÅ∞ÏóêÏÑú ÏÇ¨Ïö©Ïûê ID Ï∂îÏ∂ú Ïã§Ìå®:', error);
      return null;
    }
  };

  // Î©îÏãúÏßÄÏóêÏÑú Ïã§Ï†ú Î©§Î≤Ñ Î™©Î°ùÏùÑ Ï∂îÏ∂úÌïòÎäî Ìï®Ïàò
  const extractMembersFromMessages = (messages: ChatMessage[]) => {
    const memberMap = new Map<number, any>();

    messages.forEach((message) => {
      if (message.sender && message.sender.id) {
        const senderId = message.sender.id;
        if (!memberMap.has(senderId)) {
          memberMap.set(senderId, {
            memberId: senderId,
            name: message.sender.name || 'Unknown',
            avatarKey: message.sender.avatarUrl || '',
            avatarVersion: 0, // ChatSenderÏóê avatarVersionÏù¥ ÏóÜÏúºÎØÄÎ°ú Í∏∞Î≥∏Í∞í ÏÇ¨Ïö©
            roomRole:
              senderId === currentUserId && role === 'LEADER'
                ? 'LEADER'
                : 'MEMBER',
          });
        }
      }
    });

    // ÌåÄÏû•ÏùÑ Îß® ÏúÑÎ°ú, ÎÇòÎ®∏ÏßÄÎäî Ïù¥Î¶ÑÏàúÏúºÎ°ú Ï†ïÎ†¨
    const members = Array.from(memberMap.values()).sort((a, b) => {
      if (a.roomRole === 'LEADER' && b.roomRole !== 'LEADER') return -1;
      if (a.roomRole !== 'LEADER' && b.roomRole === 'LEADER') return 1;
      return a.name.localeCompare(b.name);
    });

    console.log('üìã Î©îÏãúÏßÄÏóêÏÑú Ï∂îÏ∂úÌïú Ïã§Ï†ú Î©§Î≤Ñ Î™©Î°ù:', members);
    return members;
  };

  // Î©îÏãúÏßÄ ÌûàÏä§ÌÜ†Î¶¨ Î°úÎìú Ìï®Ïàò
  const loadMessageHistory = async () => {
    if (!id) return;

    try {
      console.log('üöÄ Î©îÏãúÏßÄ ÌûàÏä§ÌÜ†Î¶¨ Î°úÎìú ÏãúÏûë - roomId:', id);
      const historyResponse = await getMessageHistory(Number(id));

      // API ÏùëÎãµÏùÑ STOMP Î©îÏãúÏßÄ ÌòïÏãùÏúºÎ°ú Î≥ÄÌôò
      const historyMessages: ChatMessage[] = historyResponse.items.map(
        (apiMessage: ApiChatMessage) => ({
          messageId: apiMessage.messageId,
          roomId: apiMessage.roomId,
          clientMessageId: apiMessage.clientMessageId,
          type: apiMessage.type,
          content: apiMessage.content,
          createdAt: apiMessage.createdAt,
          sender: apiMessage.sender,
          attachments: apiMessage.attachments || [],
        })
      );

      console.log(
        '‚úÖ Î©îÏãúÏßÄ ÌûàÏä§ÌÜ†Î¶¨ Î°úÎìú ÏôÑÎ£å:',
        historyMessages.length,
        'Í∞ú'
      );
      setMessages(historyMessages);

      // Î©îÏãúÏßÄÏóêÏÑú Ïã§Ï†ú Î©§Î≤Ñ Î™©Î°ù Ï∂îÏ∂ú
      const extractedMembers = extractMembersFromMessages(historyMessages);
      setActualMembers(extractedMembers);

      // ÌûàÏä§ÌÜ†Î¶¨ Î°úÎìú ÌõÑ Ïä§ÌÅ¨Î°§ÏùÑ Îß® ÏïÑÎûòÎ°ú
      setTimeout(() => {
        scrollViewRef.current?.scrollToEnd({ animated: false });
      }, 200);
    } catch (error) {
      console.error('‚ùå Î©îÏãúÏßÄ ÌûàÏä§ÌÜ†Î¶¨ Î°úÎìú Ïã§Ìå®:', error);
      // ÏóêÎü¨Í∞Ä Î∞úÏÉùÌï¥ÎèÑ ÏõπÏÜåÏºì Ïó∞Í≤∞ÏùÄ Í≥ÑÏÜç ÏßÑÌñâ
    }
  };

  // ÌòÑÏû¨ ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥ Î°úÎìú
  useEffect(() => {
    const loadCurrentUserInfo = async () => {
      try {
        const userInfo = await getUserInfo();
        setCurrentUserName(userInfo.name);
        console.log('üë§ ÌòÑÏû¨ ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥:', userInfo);
      } catch (error) {
        console.error('‚ùå ÌòÑÏû¨ ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥ Î°úÎìú Ïã§Ìå®:', error);
      }
    };

    loadCurrentUserInfo();
  }, []);

  // role Î∞è success Ï†ïÎ≥¥ Î°úÍπÖ
  useEffect(() => {
    if (role) {
      console.log('üëë Ï±ÑÌåÖÎ∞©ÏóêÏÑú ÏÇ¨Ïö©Ïûê Ïó≠Ìï†:', role);
      console.log('üè† Ï±ÑÌåÖÎ∞© ID:', id);
    }

    if (success !== undefined) {
      const isCompleted = success === 'true';
      setIsTeamCompleted(isCompleted);
      console.log('üè† Ï±ÑÌåÖÎ∞© ÏôÑÎ£å ÏÉÅÌÉú:', isCompleted);
    }
  }, [role, id, success]);

  // Ï±ÑÌåÖÎ∞© Ï†ïÎ≥¥ Î°úÎìú
  useEffect(() => {
    loadChatRoomInfo();
  }, [id, title]);

  const loadChatRoomInfo = async () => {
    try {
      // Ïã§Ï†úÎ°úÎäî APIÏóêÏÑú Ï±ÑÌåÖÎ∞© Ï†ïÎ≥¥Î•º Í∞ÄÏ†∏ÏôÄÏïº Ìï®
      // ÌòÑÏû¨Îäî Ï†ÑÎã¨Î∞õÏùÄ titleÎßå ÏÇ¨Ïö©
      setChatRoomData((prev) => ({
        ...prev,
        title: title ? decodeURIComponent(title) : 'Ï†ïÏπòÌïô Î∞úÌëú',
        memberCount:
          actualMembers.length > 0 ? `${actualMembers.length}Î™Ö` : '0',
      }));
    } catch (error) {
      console.error('‚ùå Ï±ÑÌåÖÎ∞© Ï†ïÎ≥¥ Î°úÎìú Ïã§Ìå®:', error);
    }
  };

  // JWT ÌÜ†ÌÅ∞ Í∞ÄÏ†∏Ïò§Í∏∞ Î∞è STOMP Ïó∞Í≤∞
  useEffect(() => {
    const loadTokenAndConnect = async () => {
      try {
        const token = await getAccessToken();
        setJwt(token);
        console.log(
          '‚úÖ JWT ÌÜ†ÌÅ∞ Î°úÎìú ÏôÑÎ£å:',
          token ? 'ÌÜ†ÌÅ∞ Ï°¥Ïû¨' : 'ÌÜ†ÌÅ∞ ÏóÜÏùå'
        );

        // ÌÜ†ÌÅ∞ÏóêÏÑú ÏÇ¨Ïö©Ïûê ID Ï∂îÏ∂ú
        if (token) {
          const userId = getUserIdFromToken(token);
          setCurrentUserId(userId);
          console.log('üë§ ÌòÑÏû¨ ÏÇ¨Ïö©Ïûê ID:', userId);
        }

        if (token) {
          // Î©îÏãúÏßÄ ÌûàÏä§ÌÜ†Î¶¨ Î°úÎìú (ÏõπÏÜåÏºì Ïó∞Í≤∞Í≥º Î≥ëÎ†¨Î°ú Ïã§Ìñâ)
          loadMessageHistory();

          // SockJS Ïó∞Í≤∞ ÏãúÏûë
          setConnectionStatus('connecting');

          try {
            await connectSock(token);

            // connectSockÏù¥ ÏÑ±Í≥µÌñàÎã§Î©¥ Ïó∞Í≤∞Îêú Í≤ÉÏúºÎ°ú Í∞ÑÏ£º
            setIsConnected(true);
            setConnectionStatus('connected');
            console.log('‚úÖ SockJS Ïó∞Í≤∞ ÏÑ±Í≥µ');

            // Ï±ÑÌåÖÎ∞© Íµ¨ÎèÖ (Ïó∞Í≤∞ ÏôÑÎ£å ÌõÑ ÏïΩÍ∞ÑÏùò ÏßÄÏó∞)
            setTimeout(() => {
              console.log('üîî Íµ¨ÎèÖ ÏãúÏûë - Î∞© ID:', Number(id));
              const unsubscribe = subscribeRoomSock(Number(id), (message) => {
                console.log('üì® ÏÉà Î©îÏãúÏßÄ ÏàòÏã†:', message);
                console.log('üì® Î©îÏãúÏßÄ ÌÉÄÏûÖ:', typeof message);
                console.log(
                  'üì® Î©îÏãúÏßÄ ÎÇ¥Ïö©:',
                  JSON.stringify(message, null, 2)
                );
                setMessages((prev) => {
                  console.log('üì® Ïù¥Ï†Ñ Î©îÏãúÏßÄ Í∞úÏàò:', prev.length);

                  // Ï§ëÎ≥µ Î©îÏãúÏßÄ Ï≤¥ÌÅ¨ (messageIdÎ°ú ÌôïÏù∏)
                  const isDuplicate = prev.some(
                    (existingMessage) =>
                      existingMessage.messageId === message.messageId
                  );

                  if (isDuplicate) {
                    console.log('üì® Ï§ëÎ≥µ Î©îÏãúÏßÄ Î¨¥Ïãú:', message.messageId);
                    return prev;
                  }

                  // ÏÉà Î©îÏãúÏßÄ Ï∂îÍ∞Ä ÌõÑ ÏãúÍ∞ÑÏàúÏúºÎ°ú Ï†ïÎ†¨
                  const newMessages = [...prev, message].sort((a, b) => {
                    const timeA = a.createdAt
                      ? new Date(a.createdAt).getTime()
                      : 0;
                    const timeB = b.createdAt
                      ? new Date(b.createdAt).getTime()
                      : 0;
                    return timeA - timeB;
                  });

                  console.log('üì® ÏÉàÎ°úÏö¥ Î©îÏãúÏßÄ Í∞úÏàò:', newMessages.length);

                  // ÏÉà Î©îÏãúÏßÄÍ∞Ä Ï∂îÍ∞ÄÎêòÎ©¥ ÏûêÎèôÏúºÎ°ú Ïä§ÌÅ¨Î°§ÏùÑ Îß® ÏïÑÎûòÎ°ú
                  setTimeout(() => {
                    scrollViewRef.current?.scrollToEnd({ animated: true });
                  }, 100);

                  return newMessages;
                });
              });
              console.log('üîî Íµ¨ÎèÖ Ìï®Ïàò Î∞òÌôòÎê®');

              // Ïª¥Ìè¨ÎÑåÌä∏ Ïñ∏ÎßàÏö¥Ìä∏ Ïãú Ï†ïÎ¶¨
              return () => {
                console.log('üîî Íµ¨ÎèÖ Ìï¥Ï†ú');
                unsubscribe();
                disconnectSock();
              };
            }, 1000);
          } catch (error) {
            console.error('SockJS Ïó∞Í≤∞ Ïã§Ìå®:', error);
            setConnectionStatus('error');
            throw error;
          }
        }
      } catch (error) {
        console.error('ÌÜ†ÌÅ∞ Î°úÎìú ÎòêÎäî Ïó∞Í≤∞ Ïã§Ìå®:', error);
        setConnectionStatus('error');
        Alert.alert(
          'Ïò§Î•ò',
          'Ïù∏Ï¶ù ÌÜ†ÌÅ∞ÏùÑ Í∞ÄÏ†∏Ïò¨ Ïàò ÏóÜÍ±∞ÎÇò Ïó∞Í≤∞Ïóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.'
        );
      } finally {
        setIsLoading(false);
      }
    };

    loadTokenAndConnect();
  }, [id]);

  // Ï±ÑÌåÖÎ∞© Îç∞Ïù¥ÌÑ∞ - Ïã§Ï†ú APIÏóêÏÑú Í∞ÄÏ†∏Ïò¨ Îç∞Ïù¥ÌÑ∞
  const [chatRoomData, setChatRoomData] = useState<ChatRoomData>({
    id: Number(id),
    title: title ? decodeURIComponent(title) : 'Ï†ïÏπòÌïô Î∞úÌëú',
    subtitle: 'Ï†ïÏπòÌïôÍ∞úÎ°†',
    members: null,
    memberCount: '0',
  });

  // Î©îÏãúÏßÄ Î™©Î°ùÏùÑ ÌëúÏãúÏö© Î©îÏãúÏßÄÎ°ú Î≥ÄÌôò
  console.log('üîÑ ÌòÑÏû¨ Î©îÏãúÏßÄ Í∞úÏàò:', messages.length);
  console.log('üîÑ ÌòÑÏû¨ Î©îÏãúÏßÄÎì§:', messages);
  console.log('üë§ ÌòÑÏû¨ ÏÇ¨Ïö©Ïûê ID:', currentUserId);
  const displayMessages = messages.map((msg: ChatMessage) => ({
    id: msg.messageId || 0,
    text: msg.content || '',
    user: msg.sender?.name || 'Unknown',
    userImage: msg.sender?.avatarUrl ? { uri: msg.sender.avatarUrl } : null,
    timestamp: msg.createdAt
      ? new Date(msg.createdAt).toLocaleTimeString('ko-KR', {
          hour: '2-digit',
          minute: '2-digit',
          hour12: true,
        })
      : new Date().toLocaleTimeString('ko-KR', {
          hour: '2-digit',
          minute: '2-digit',
          hour12: true,
        }),
    isMe: currentUserId !== null && msg.sender?.id === currentUserId, // ÌòÑÏû¨ ÏÇ¨Ïö©Ïûê IDÏôÄ ÎπÑÍµê
    attachments: msg.attachments || [], // ÌååÏùº Ï≤®Î∂Ä Ï†ïÎ≥¥ Ï∂îÍ∞Ä
    // readCount: 1, // TODO: Ïã§Ï†ú ÏùΩÏùå Ïàò Íµ¨ÌòÑ - Ï£ºÏÑù Ï≤òÎ¶¨ (ÎÇòÏ§ëÏóê ÏÇ¨Ïö© ÏòàÏ†ï)
  }));

  const handleBackPress = () => {
    // Ï¢åÏ∏° Ïä¨ÎùºÏù¥Îìú Ïï†ÎãàÎ©îÏù¥ÏÖòÏúºÎ°ú Îí§Î°úÍ∞ÄÍ∏∞
    router.back();
  };

  const handleMenuPress = () => {
    // URL ÌååÎùºÎØ∏ÌÑ∞ÏóêÏÑú ÌåÄÏû• Ïó¨Î∂Ä ÌôïÏù∏
    const isTeamLeader = role === 'LEADER';

    // Ïã§Ï†ú Î©§Î≤Ñ Ï†ïÎ≥¥Î•º Ï†ÑÎã¨ (Î©îÏãúÏßÄÏóêÏÑú Ï∂îÏ∂úÌïú Ï†ïÎ≥¥ Ïö∞ÏÑ† ÏÇ¨Ïö©)
    let membersToPass = actualMembers;
    if (membersToPass.length === 0 && members) {
      // actualMembersÍ∞Ä ÏóÜÏúºÎ©¥ Í∏∞Ï°¥ members ÏÇ¨Ïö©
      try {
        membersToPass = JSON.parse(decodeURIComponent(members as string));
      } catch (error) {
        console.error('‚ùå members ÌååÏã± Ïã§Ìå®:', error);
        membersToPass = [];
      }
    }

    const membersParam =
      membersToPass.length > 0
        ? `&members=${encodeURIComponent(JSON.stringify(membersToPass))}`
        : '';
    const titleParam = title ? `&title=${encodeURIComponent(title)}` : '';
    router.push(
      `/(tabs)/chats/chat-menu?roomId=${id}&isLeader=${isTeamLeader}&isCompleted=${isTeamCompleted}${membersParam}${titleParam}`
    );
  };

  const handleSendMessage = () => {
    console.log('üì§ Î©îÏãúÏßÄ Ï†ÑÏÜ° Î≤ÑÌäº ÌÅ¥Î¶≠:', {
      inputText: inputText.trim(),
      isConnected,
      connectionStatus,
    });

    if (inputText.trim() && isConnected) {
      // SockJS ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏Î°ú Î©îÏãúÏßÄ Ï†ÑÏÜ°
      console.log('üì§ Î©îÏãúÏßÄ Ï†ÑÏÜ° ÏãúÏûë:', inputText.trim());
      sendTextSock(Number(id), inputText.trim());
      console.log('üì§ Î©îÏãúÏßÄ Ï†ÑÏÜ° ÏôÑÎ£å');
      setInputText('');

      // Ïä§ÌÅ¨Î°§ÏùÑ Îß® ÏïÑÎûòÎ°ú
      setTimeout(() => {
        scrollViewRef.current?.scrollToEnd({ animated: true });
      }, 100);
    } else if (!isConnected) {
      Alert.alert('Ïó∞Í≤∞ Ïò§Î•ò', 'ÏõπÏÜåÏºìÏù¥ Ïó∞Í≤∞ÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§.');
    }
  };

  const handleImagePicker = async () => {
    try {
      const result = await ImagePicker.launchImageLibraryAsync({
        mediaTypes: ImagePicker.MediaTypeOptions.Images,
        allowsEditing: true,
        aspect: [4, 3],
        quality: 0.8,
      });

      if (!result.canceled && result.assets[0]) {
        const asset = result.assets[0];
        if (isConnected) {
          await uploadAndSendFile(
            asset.uri,
            asset.fileName || 'Ïù¥ÎØ∏ÏßÄ',
            asset.type || 'image/jpeg',
            asset.fileSize || 0,
            'image'
          );
        } else {
          Alert.alert('Ïó∞Í≤∞ Ïò§Î•ò', 'ÏõπÏÜåÏºìÏù¥ Ïó∞Í≤∞ÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§.');
        }
        setShowFileMenu(false);
      }
    } catch (error) {
      console.error('Ïù¥ÎØ∏ÏßÄ ÏÑ†ÌÉù Ïò§Î•ò:', error);
      Alert.alert('Ïò§Î•ò', 'Ïù¥ÎØ∏ÏßÄÎ•º ÏÑ†ÌÉùÌïòÎäî Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.');
    }
  };

  const handleVideoPicker = async () => {
    try {
      const result = await ImagePicker.launchImageLibraryAsync({
        mediaTypes: ImagePicker.MediaTypeOptions.Videos,
        allowsEditing: true,
        quality: 0.8,
      });

      if (!result.canceled && result.assets[0]) {
        const asset = result.assets[0];
        if (isConnected) {
          await uploadAndSendFile(
            asset.uri,
            asset.fileName || 'ÎèôÏòÅÏÉÅ',
            asset.type || 'video/mp4',
            asset.fileSize || 0,
            'video'
          );
        } else {
          Alert.alert('Ïó∞Í≤∞ Ïò§Î•ò', 'ÏõπÏÜåÏºìÏù¥ Ïó∞Í≤∞ÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§.');
        }
        setShowFileMenu(false);
      }
    } catch (error) {
      console.error('ÎèôÏòÅÏÉÅ ÏÑ†ÌÉù Ïò§Î•ò:', error);
      Alert.alert('Ïò§Î•ò', 'ÎèôÏòÅÏÉÅÏùÑ ÏÑ†ÌÉùÌïòÎäî Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.');
    }
  };

  const handleDocumentPicker = async () => {
    try {
      const result = await DocumentPicker.getDocumentAsync({
        type: '*/*',
        copyToCacheDirectory: true,
      });

      if (!result.canceled && result.assets[0]) {
        const asset = result.assets[0];
        if (isConnected) {
          await uploadAndSendFile(
            asset.uri,
            asset.name,
            asset.mimeType || 'application/octet-stream',
            asset.size || 0,
            'document'
          );
        } else {
          Alert.alert('Ïó∞Í≤∞ Ïò§Î•ò', 'ÏõπÏÜåÏºìÏù¥ Ïó∞Í≤∞ÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§.');
        }
        setShowFileMenu(false);
      }
    } catch (error) {
      console.error('Î¨∏ÏÑú ÏÑ†ÌÉù Ïò§Î•ò:', error);
      Alert.alert('Ïò§Î•ò', 'ÌååÏùºÏùÑ ÏÑ†ÌÉùÌïòÎäî Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.');
    }
  };

  // ÌååÏùº ÏóÖÎ°úÎìú Î∞è Ï†ÑÏÜ° ÌÜµÌï© Ìï®Ïàò
  const uploadAndSendFile = async (
    fileUri: string,
    fileName: string,
    contentType: string,
    fileSize: number,
    fileType: 'image' | 'video' | 'document'
  ) => {
    try {
      setIsUploading(true);
      setUploadProgress({ loaded: 0, total: fileSize, percentage: 0 });

      console.log('üì§ ÌååÏùº ÏóÖÎ°úÎìú ÏãúÏûë:', {
        fileName,
        contentType,
        fileSize: FileService.formatFileSize(fileSize),
        fileType,
      });

      // S3Ïóê ÌååÏùº ÏóÖÎ°úÎìú
      const fileId = await FileService.uploadFile(
        Number(id),
        fileUri,
        fileName,
        contentType,
        fileSize,
        (progress) => {
          setUploadProgress(progress);
          console.log(`üìä ÏóÖÎ°úÎìú ÏßÑÌñâÎ•†: ${progress.percentage.toFixed(1)}%`);
        }
      );

      console.log('‚úÖ ÌååÏùº ÏóÖÎ°úÎìú ÏôÑÎ£å, fileId:', fileId);

      // SockJS ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏Î°ú ÌååÏùº Î©îÏãúÏßÄ Ï†ÑÏÜ°
      if (fileType === 'image') {
        sendImageSock(Number(id), fileName, [fileId]);
      } else if (fileType === 'video') {
        sendFileSock(Number(id), fileName, [fileId]);
      } else {
        sendFileSock(Number(id), fileName, [fileId]);
      }

      Alert.alert('Ï†ÑÏÜ° ÏôÑÎ£å', `${fileName}Ïù¥(Í∞Ä) Ï†ÑÏÜ°ÎêòÏóàÏäµÎãàÎã§.`);

      // Ïä§ÌÅ¨Î°§ÏùÑ Îß® ÏïÑÎûòÎ°ú
      setTimeout(() => {
        scrollViewRef.current?.scrollToEnd({ animated: true });
      }, 100);
    } catch (error: any) {
      console.error('‚ùå ÌååÏùº ÏóÖÎ°úÎìú Ïã§Ìå®:', error);
      Alert.alert(
        'ÏóÖÎ°úÎìú Ïã§Ìå®',
        `ÌååÏùº ÏóÖÎ°úÎìú Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.\n${
          error.message || 'Ïïå Ïàò ÏóÜÎäî Ïò§Î•ò'
        }`
      );
    } finally {
      setIsUploading(false);
      setUploadProgress(null);
    }
  };

  const renderMessage = (message: Message, index: number) => {
    const prevMessage = index > 0 ? displayMessages[index - 1] : null;

    // Ïπ¥Ïπ¥Ïò§ÌÜ°Í≥º ÎèôÏùºÌïú Î°úÏßÅ: Í∞ôÏùÄ ÏÇ¨Îûå + Í∞ôÏùÄ ÏãúÍ∞ÑÎåÄ = Ïó∞ÏÜç Î©îÏãúÏßÄ
    const isSameUser = prevMessage
      ? prevMessage.user === message.user && prevMessage.isMe === message.isMe
      : false;
    const isSameTime = prevMessage
      ? prevMessage.timestamp === message.timestamp
      : false;
    const isContinuous = isSameUser && isSameTime;

    // ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥ ÌëúÏãú: Ï≤´ Î≤àÏß∏ Î©îÏãúÏßÄÏù¥Í±∞ÎÇò Îã§Î•∏ ÏÇ¨ÎûåÏù¥Í±∞ÎÇò Îã§Î•∏ ÏãúÍ∞ÑÎåÄ
    const showUserInfo = !isContinuous && !message.isMe;

    // Íº¨Î¶¨ ÌëúÏãú: Îã§Î•∏ ÏÇ¨ÎûåÏùò Ï≤´ Î≤àÏß∏ Î©îÏãúÏßÄ (Ïó∞ÏÜç Î©îÏãúÏßÄÍ∞Ä ÏïÑÎãå Í≤ΩÏö∞)
    const showTail = !message.isMe && !isContinuous;

    return (
      <View key={message.id} style={styles.messageContainer}>
        {showUserInfo && (
          <View style={styles.userInfo}>
            <Image source={message.userImage} style={styles.userAvatar} />
            <Text style={styles.userName}>{message.user}</Text>
          </View>
        )}

        <ChatBubble
          text={message.text}
          isMe={message.isMe}
          showTail={showTail}
          isContinuous={isContinuous}
          timestamp={message.timestamp}
          attachments={message.attachments}
          // readCount={message.readCount} // Ï£ºÏÑù Ï≤òÎ¶¨ (ÎÇòÏ§ëÏóê ÏÇ¨Ïö© ÏòàÏ†ï)
          backgroundColor={message.isMe ? '#007AFF' : '#121216'}
          textColor="#FFFFFF"
        />
      </View>
    );
  };

  // Î°úÎî© Ï§ëÏùº Îïå
  if (isLoading) {
    return (
      <View style={styles.container}>
        <StatusBar style="light" />
        <View style={styles.loadingContainer}>
          <ActivityIndicator size="large" color="#4A90E2" />
          <Text style={styles.loadingText}>Ï±ÑÌåÖÎ∞©Ïóê Ïó∞Í≤∞ÌïòÎäî Ï§ë...</Text>
        </View>
      </View>
    );
  }

  // JWTÍ∞Ä ÏóÜÏùÑ Îïå
  if (!jwt) {
    return (
      <View style={styles.container}>
        <StatusBar style="light" />
        <View style={styles.errorContainer}>
          <Ionicons name="alert-circle" size={48} color="#FF6B6B" />
          <Text style={styles.errorText}>Ïù∏Ï¶ù ÌÜ†ÌÅ∞ÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.</Text>
          <TouchableOpacity
            style={styles.retryButton}
            onPress={() => router.back()}
          >
            <Text style={styles.retryButtonText}>ÎèåÏïÑÍ∞ÄÍ∏∞</Text>
          </TouchableOpacity>
        </View>
      </View>
    );
  }

  return (
    <View style={styles.container}>
      <StatusBar style="light" />

      {/* Ìó§Îçî */}
      <View style={styles.header}>
        <TouchableOpacity onPress={handleBackPress} style={styles.backButton}>
          <Ionicons name="chevron-back" size={24} color="#FFFFFF" />
        </TouchableOpacity>
        <View style={styles.headerCenter}>
          <Text style={styles.headerTitle}>{chatRoomData.title}</Text>
          <View style={styles.connectionStatus}>
            <View
              style={[
                styles.statusDot,
                { backgroundColor: isConnected ? '#4CAF50' : '#FF6B6B' },
              ]}
            />
            <Text style={styles.statusText}>
              {isConnected
                ? 'Ïó∞Í≤∞Îê®'
                : connectionStatus === 'connecting'
                ? 'Ïó∞Í≤∞ Ï§ë...'
                : 'Ïó∞Í≤∞ ÎÅäÍπÄ'}
            </Text>
          </View>
        </View>
        <TouchableOpacity onPress={handleMenuPress} style={styles.menuButton}>
          <Ionicons name="ellipsis-horizontal" size={24} color="#FFFFFF" />
        </TouchableOpacity>
      </View>

      {/* Î©îÏãúÏßÄ Î™©Î°ù */}
      <KeyboardAvoidingView
        style={styles.chatContainer}
        behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
        keyboardVerticalOffset={Platform.OS === 'ios' ? 0 : 0}
      >
        <ScrollView
          ref={scrollViewRef}
          style={styles.messagesContainer}
          contentContainerStyle={styles.messagesContent}
          showsVerticalScrollIndicator={false}
        >
          {displayMessages.map((message, index) =>
            renderMessage(message, index)
          )}
        </ScrollView>

        {/* Î©îÏãúÏßÄ ÏûÖÎ†•Ï∞Ω */}
        <View style={styles.inputContainer}>
          <TouchableOpacity
            style={styles.plusButton}
            onPress={() => setShowFileMenu(true)}
          >
            <Ionicons name="add" size={24} color="#007AFF" />
          </TouchableOpacity>

          <TextInput
            style={styles.textInput}
            value={inputText}
            onChangeText={setInputText}
            placeholder="Î©îÏãúÏßÄÎ•º ÏûÖÎ†•ÌïòÏÑ∏Ïöî"
            placeholderTextColor="#666666"
            multiline
            maxLength={500}
          />

          <TouchableOpacity
            style={[
              styles.sendButton,
              inputText.trim()
                ? styles.sendButtonActive
                : styles.sendButtonInactive,
            ]}
            onPress={handleSendMessage}
            disabled={!inputText.trim()}
          >
            <Ionicons
              name="arrow-up"
              size={20}
              color={inputText.trim() ? '#FFFFFF' : '#666666'}
            />
          </TouchableOpacity>
        </View>

        {/* ÌååÏùº ÏÑ†ÌÉù Î©îÎâ¥ Î™®Îã¨ */}
        <Modal
          visible={showFileMenu}
          transparent={true}
          animationType="fade"
          onRequestClose={() => setShowFileMenu(false)}
        >
          <TouchableOpacity
            style={styles.modalOverlay}
            activeOpacity={1}
            onPress={() => setShowFileMenu(false)}
          >
            <View style={styles.fileMenuContainer}>
              <TouchableOpacity
                style={styles.fileMenuOption}
                onPress={handleImagePicker}
                disabled={isUploading}
              >
                <View style={styles.fileMenuIcon}>
                  <Ionicons name="image" size={24} color="#FF2D92" />
                </View>
                <Text style={styles.fileMenuText}>Ïù¥ÎØ∏ÏßÄ</Text>
              </TouchableOpacity>

              <TouchableOpacity
                style={styles.fileMenuOption}
                onPress={handleVideoPicker}
                disabled={isUploading}
              >
                <View style={styles.fileMenuIcon}>
                  <Ionicons name="videocam" size={24} color="#AF52DE" />
                </View>
                <Text style={styles.fileMenuText}>ÎèôÏòÅÏÉÅ</Text>
              </TouchableOpacity>

              <TouchableOpacity
                style={styles.fileMenuOption}
                onPress={handleDocumentPicker}
                disabled={isUploading}
              >
                <View style={styles.fileMenuIcon}>
                  <Ionicons name="document" size={24} color="#007AFF" />
                </View>
                <Text style={styles.fileMenuText}>ÌååÏùº</Text>
              </TouchableOpacity>
            </View>
          </TouchableOpacity>
        </Modal>

        {/* ÏóÖÎ°úÎìú ÏßÑÌñâÎ•† Î™®Îã¨ */}
        <Modal visible={isUploading} transparent={true} animationType="fade">
          <View style={styles.uploadModalOverlay}>
            <View style={styles.uploadModalContainer}>
              <ActivityIndicator size="large" color="#007AFF" />
              <Text style={styles.uploadModalTitle}>ÌååÏùº ÏóÖÎ°úÎìú Ï§ë...</Text>
              {uploadProgress && (
                <View style={styles.progressContainer}>
                  <View style={styles.progressBar}>
                    <View
                      style={[
                        styles.progressFill,
                        { width: `${uploadProgress.percentage}%` },
                      ]}
                    />
                  </View>
                  <Text style={styles.progressText}>
                    {uploadProgress.percentage.toFixed(1)}%
                  </Text>
                </View>
              )}
            </View>
          </View>
        </Modal>
      </KeyboardAvoidingView>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#000000',
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingHorizontal: 20,
    paddingTop: 60,
    paddingBottom: 16,
    backgroundColor: '#000000', // Ìó§Îçî Î∞∞Í≤ΩÏÉâÏùÑ Í≤ÄÏùÄÏÉâÏúºÎ°ú ÏÑ§Ï†ï
    borderBottomWidth: 1,
    borderBottomColor: '#292929',
  },
  backButton: {
    padding: 8,
    marginRight: 8,
  },
  headerCenter: {
    flex: 1,
    alignItems: 'center',
  },
  headerTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#FFFFFF',
  },
  menuButton: {
    padding: 8,
    marginLeft: 8,
  },
  chatContainer: {
    flex: 1,
  },
  messagesContainer: {
    flex: 1,
  },
  messagesContent: {
    paddingHorizontal: 16,
    paddingVertical: 12,
  },
  messageContainer: {
    marginBottom: 8,
  },
  userInfo: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 4,
    marginLeft: -10,
  },
  userAvatar: {
    width: 30,
    height: 30,
    borderRadius: 12,
    marginRight: 8,
  },
  userName: {
    fontSize: 12,
    color: '#CCCCCC',
    fontWeight: '500',
  },
  inputContainer: {
    flexDirection: 'row',
    alignItems: 'flex-end',
    paddingHorizontal: 16,
    paddingVertical: 10,
    backgroundColor: '#121216',
    borderTopWidth: 1,
    borderTopColor: '#292929',
  },
  plusButton: {
    width: 30,
    height: 30,
    borderRadius: 20,
    backgroundColor: '#1A1A1A',
    alignItems: 'center',
    justifyContent: 'center',
    marginRight: 8,
    borderWidth: 1,
    borderColor: '#292929',
  },
  textInput: {
    flex: 1,
    backgroundColor: '#1A1A1A',
    borderRadius: 20,
    borderWidth: 1,
    borderColor: '#292929',
    paddingHorizontal: 16,
    paddingVertical: 8,
    fontSize: 12,
    color: '#FFFFFF',
    maxHeight: 50,
    marginRight: 12,
  },
  sendButton: {
    width: 30,
    height: 30,
    borderRadius: 20,
    alignItems: 'center',
    justifyContent: 'center',
  },
  sendButtonActive: {
    backgroundColor: '#007AFF',
  },
  sendButtonInactive: {
    backgroundColor: '#292929',
  },
  modalOverlay: {
    flex: 1,
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
    justifyContent: 'flex-end',
  },
  fileMenuContainer: {
    backgroundColor: '#121216',
    borderTopLeftRadius: 20,
    borderTopRightRadius: 20,
    paddingHorizontal: 20,
    paddingVertical: 30,
    paddingBottom: 50,
    borderWidth: 1,
    borderColor: '#292929',
    borderBottomWidth: 0,
  },
  fileMenuOption: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: 16,
    paddingHorizontal: 12,
    borderRadius: 12,
    marginBottom: 8,
  },
  fileMenuIcon: {
    width: 48,
    height: 48,
    borderRadius: 24,
    backgroundColor: '#1A1A1A',
    alignItems: 'center',
    justifyContent: 'center',
    marginRight: 16,
  },
  fileMenuText: {
    fontSize: 16,
    fontWeight: '500',
    color: '#FFFFFF',
  },

  // Ïó∞Í≤∞ ÏÉÅÌÉú
  connectionStatus: {
    flexDirection: 'row',
    alignItems: 'center',
    marginTop: 4,
  },
  statusDot: {
    width: 8,
    height: 8,
    borderRadius: 4,
    marginRight: 6,
  },
  statusText: {
    fontSize: 12,
    color: '#CCCCCC',
  },

  // Î°úÎî© ÏÉÅÌÉú
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    paddingVertical: 60,
  },
  loadingText: {
    fontSize: 16,
    color: '#CCCCCC',
    marginTop: 16,
  },

  // ÏóêÎü¨ ÏÉÅÌÉú
  errorContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    paddingVertical: 60,
    paddingHorizontal: 40,
  },
  errorText: {
    fontSize: 16,
    color: '#FF6B6B',
    textAlign: 'center',
    marginTop: 16,
    marginBottom: 24,
  },
  retryButton: {
    backgroundColor: '#4A90E2',
    paddingHorizontal: 24,
    paddingVertical: 12,
    borderRadius: 8,
  },
  retryButtonText: {
    fontSize: 16,
    color: '#FFFFFF',
    fontWeight: '600',
  },

  // ÏóÖÎ°úÎìú ÏßÑÌñâÎ•† Î™®Îã¨
  uploadModalOverlay: {
    flex: 1,
    backgroundColor: 'rgba(0, 0, 0, 0.7)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  uploadModalContainer: {
    backgroundColor: '#121216',
    borderRadius: 16,
    padding: 24,
    alignItems: 'center',
    minWidth: 200,
    borderWidth: 1,
    borderColor: '#292929',
  },
  uploadModalTitle: {
    fontSize: 16,
    fontWeight: '600',
    color: '#FFFFFF',
    marginTop: 16,
    marginBottom: 20,
  },
  progressContainer: {
    width: '100%',
    alignItems: 'center',
  },
  progressBar: {
    width: '100%',
    height: 8,
    backgroundColor: '#292929',
    borderRadius: 4,
    overflow: 'hidden',
    marginBottom: 8,
  },
  progressFill: {
    height: '100%',
    backgroundColor: '#007AFF',
    borderRadius: 4,
  },
  progressText: {
    fontSize: 14,
    color: '#CCCCCC',
    fontWeight: '500',
  },
});
